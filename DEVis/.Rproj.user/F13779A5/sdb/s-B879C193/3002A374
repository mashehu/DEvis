{
    "collab_server" : "",
    "contents" : "\n\n#' create_dir_struct\n#'\n#' This function creates the directory structure for DE analysis based on a provided base directory.\n#' Note that this function will not overwrite existing directories.  Initialization of\n#' data directories should be done by using init_data_paths().\n#' @param base_dir Base directory in which to build structure for DE output.\n#' @keywords directory structure organization\n#' @export\n#' @examples\n#' create_dir_struct(\"/Users/adam/code/\")\ncreate_dir_struct <- function(base_dir)\n{\n  #Establish Paths.\n  working_dir    <<- base_dir\n  results_dir    <<- paste(working_dir,\"results/\", sep=\"\")\n  norm_dir       <<- paste(results_dir,\"normalization/\", sep=\"\")\n  DE_base_dir    <<- paste(results_dir,\"DE/\", sep=\"\")\n  DE_dir         <<- paste(results_dir,\"DE/data\", sep=\"\")\n  DE_stats_dir   <<- paste(results_dir,\"DE/stats\", sep=\"\")\n  DE_hm_base_dir <<- paste(results_dir,\"DE/heatmaps/\", sep=\"\")\n  DE_up_dir      <<- paste(results_dir,\"DE/heatmaps/upreg/\", sep=\"\")\n  DE_down_dir    <<- paste(results_dir,\"DE/heatmaps/downreg/\", sep=\"\")\n  DE_all_dir     <<- paste(results_dir,\"DE/heatmaps/all\", sep=\"\")\n  DE_count_dir   <<- paste(results_dir,\"DE/counts\", sep=\"\")\n  DE_master_dir  <<- paste(results_dir,\"DE/heatmaps/master\", sep=\"\")\n  top_100_dir    <<- paste(results_dir,\"DE/heatmaps/top100/\", sep=\"\")\n  clust_stat_dir <<- paste(results_dir,\"DE/stats\", sep=\"\")\n  high_var_dir   <<- paste(results_dir,\"DE/heatmaps/high_variance/\", sep=\"\")\n  MDS_base       <<- paste(results_dir,\"MDS/\", sep=\"\")\n  MDS_dir        <<- paste(results_dir,\"MDS/standard/\", sep=\"\")\n  distance_dir   <<- paste(results_dir,\"sample_distance/\", sep=\"\")\n  euclidian_dir  <<- paste(results_dir,\"sample_distance/Euclidian/\", sep=\"\")\n  poisson_dir    <<- paste(results_dir,\"sample_distance/Poisson/\", sep=\"\")\n  MA_dir         <<- paste(results_dir,\"MA/\", sep=\"\")\n  PCA_dir        <<- paste(results_dir,\"PCA/\", sep=\"\")\n  batch_dir      <<- paste(results_dir,\"batch/\", sep=\"\")\n\n  #Create directory structure if it doesn't exist.\n  dir.create(working_dir, showWarnings = FALSE)\n  dir.create(results_dir, showWarnings = FALSE)\n  dir.create(norm_dir, showWarnings = FALSE)\n  dir.create(DE_base_dir, showWarnings = FALSE)\n  dir.create(DE_hm_base_dir, showWarnings = FALSE)\n  dir.create(DE_dir, showWarnings = FALSE)\n  dir.create(DE_up_dir, showWarnings = FALSE)\n  dir.create(DE_down_dir , showWarnings = FALSE)\n  dir.create(DE_all_dir, showWarnings = FALSE)\n  dir.create(DE_stats_dir, showWarnings = FALSE)\n  dir.create(DE_master_dir, showWarnings = FALSE)\n  dir.create(DE_count_dir, showWarnings = FALSE)\n  dir.create(clust_stat_dir, showWarnings = FALSE)\n  dir.create(high_var_dir, showWarnings = FALSE)\n  dir.create(top_100_dir, showWarnings = FALSE)\n  dir.create(MDS_base, showWarnings = FALSE)\n  dir.create(MDS_dir, showWarnings = FALSE)\n  dir.create(distance_dir, showWarnings = FALSE)\n  dir.create(euclidian_dir, showWarnings = FALSE)\n  dir.create(poisson_dir, showWarnings = FALSE)\n  dir.create(MA_dir, showWarnings = FALSE)\n  dir.create(PCA_dir, showWarnings = FALSE)\n  dir.create(batch_dir, showWarnings = FALSE)\n\n  setwd(working_dir)\n}\n\n\n#' init_outfiles\n#'\n#' This function sets the output files destinations, prefixed with a base name. Filenames will be of the format,\n#' base_name_outfile_suffix.pdf/txt.\n#' @param base_name Base name for analysis that will preceed standard output filenames.\n#' @keywords directory filenames file organization\n#' @export\n#' @examples\n#' init_outfiles(day1_comparison)\ninit_outfiles <- function(base_name)\n{\n  base_name           <<- base_name\n  norm_plot_out       <<- paste(base_name,\"_normalization_effect.pdf\", sep=\"\")\n  euclid_plot_out     <<- paste(base_name,\"_euclidian_distance.pdf\", sep=\"\")\n  poisson_plot_out    <<- paste(base_name,\"_poisson_distance.pdf\", sep=\"\")\n  PCA_plot_out        <<- paste(base_name,\"_PCA.pdf\", sep=\"\")\n  PCA_plot_infect     <<- paste(base_name,\"_infection_PCA.pdf\", sep=\"\")\n  PCA_plot_batch      <<- paste(base_name,\"_batch_PCA.pdf\", sep=\"\")\n  MDS_plot_out        <<- paste(base_name,\"_MDS.pdf\", sep=\"\")\n  MA_plot_out         <<- paste(base_name,\"_MA.pdf\", sep=\"\")\n  DE_list_out         <<- paste(base_name,\"_DE_genes.txt\", sep=\"\")\n  DE_stats_out        <<- paste(base_name,\"_DE_stats.txt\", sep=\"\")\n  gene_cluster_out    <<- paste(base_name,\"_gene_cluster.pdf\", sep=\"\")\n  highVar_list_out    <<- paste(base_name,\"_high_variant_genes.txt\", sep=\"\")\n  cluster_stats_out   <<- paste(base_name,\"_high_variant_stats.txt\", sep=\"\")\n  upreg_plot_out      <<- paste(base_name,\"_upreg_DE_genes.pdf\", sep=\"\")\n  upreg_list_out      <<- paste(base_name,\"_top_upreg_genes.txt\", sep=\"\")\n  upreg_stats_out     <<- paste(base_name,\"_top_upreg_stats.txt\", sep=\"\")\n  downreg_plot_out    <<- paste(base_name,\"_downreg_DE_genes.pdf\", sep=\"\")\n  downreg_list_out    <<- paste(base_name,\"_top_downreg_genes.txt\", sep=\"\")\n  downreg_stats_out   <<- paste(base_name,\"_top_downreg_stats.txt\", sep=\"\")\n  batch_plot_out      <<- paste(base_name,\"_batch_cluster.pdf\", sep=\"\")\n  de_plot_out         <<- paste(base_name,\"_de_heat.pdf\", sep=\"\")\n  master_de_plot_out  <<- paste(base_name,\"_master_de_heat.pdf\", sep=\"\")\n  DE_top100_list_out  <<- paste(base_name,\"_top100_DE_genes.txt\", sep=\"\")\n  DE_top100_stats_out <<- paste(base_name,\"_top100_DE_stats.txt\", sep=\"\")\n  DE_top100_out       <<- paste(base_name,\"_top100_heat.pdf\", sep=\"\")\n  DE_count_out        <<- paste(base_name,\"_DE_count_\",as.character(signif_cutoff),\".txt\", sep=\"\")\n}\n\n\n\n#' init_lib\n#'\n#' This function loads required libraries for DE analysis using this package.\n#' @keywords library dependency\n#' @export\n#' @examples\n#' init_lib()\ninit_lib <- function()\n{\n  print(\"Loading dependencies...\")\n  #library(DESeq2)\n  library(ggplot2)\n  library(\"pheatmap\")\n  library(\"RColorBrewer\")\n  library(\"PoiClaClu\")\n  library(\"genefilter\")\n  library(\"reshape2\")\n  library(tidyr)\n  library(ggthemes)\n}\n\n\n#' init_data_paths\n#'\n#' This function initializes the paths to folders containing count and target data.\n#' These paths are stores as global variables, counts_dir and targets_dir respectively.\n#' Initialization by this function is required for some functions to work properly.\n#' @keywords initialization path directory structure\n#' @param count_path Path to directory containing counts.\n#' @param target_path Path to directory containing counts.\n#' @export\n#' @examples\n#' init_data_paths(count_dir_path, target_dir_path)\ninit_data_paths <- function(count_path, target_path)\n{\n  print(\"Initializing data paths...\")\n  counts_dir      <<- count_path\n  targets_dir     <<- target_path\n}\n\n\n#' init_cutoffs\n#'\n#' This function initializes the p-value cutoffs and log2foldChange values.\n#' @keywords cutoffs filter p-value log2foldchange fold-change\n#' @param p_signif P-value cutoff for determining DE genes. Default: 0.05\n#' @param lfc_cut Log2 fold-change cutoff used for filtering DE genes. Default: 1\n#' @export\n#' @examples\n#' init_cutoffs(0.01, 1.5)\ninit_cutoffs <- function(p_signif=0.05, lfc_cut=1)\n{\n  signif_cutoff <<- p_signif\n  lfc_cutoff    <<- lfc_cut\n}\n\n#' init_result_list\n#'\n#' This function initializes and returns an empty result list object.\n#' @keywords result list initialization\n#' @export\n#' @examples\n#' myResList <- init_result_list()\ninit_result_list <- function()\n{\n  return(list())\n}\n\n\n\n#' plot_norm\n#'\n#' This function plots count data before and after normalization. dds and rld parameters can be computed\n#' using the prep_dds function or manually using standard DESeq2 design. Output saved to PDF.\n#' @param dds A DESeq2 data object.\n#' @param rld rlog transformed data from a DESeq2 data object.\n#' @keywords normalization\n#' @export\n#' @examples\n#' plot_norm(dds,rld)\nplot_norm <- function(dds, rld)\n{\n  print(\"Plotting normalization effect on two samples.\")\n  setwd(norm_dir)\n  pdf(norm_plot_out,  width=8, height=8)\n  par( mfrow = c( 1, 2 ) )\n  plot(log2( 1 + counts(dds, normalized=TRUE)[ , 1:2] ), pch=16, cex=0.3)\n  title(\"Before Normalization\")\n  plot(assay(rld)[ , 1:2], pch=16, cex=0.3)\n  title(\"After Normalization\")\n  dev.off()\n  setwd(working_dir)\n}\n\n\n#' dendro_batch\n#'\n#' This function plots a dendrogram of provided batch information in contrast with the biological\n#' condition of interest.  Output written as PDF.\n#' @param batch_cond Batch condition as provided from targets input. (I.E. Targets$Batch)\n#' @param bio_cond Biological condition as provided from targets input. (I.E. Targets$Infection)\n#' @keywords batch dendrogram bias\n#' @export\n#' @examples\n#' dendro_batch(targetDat$Batch, targetDat$Replicate)\ndendro_batch <- function(batch_cond, bio_cond)\n{\n  print(\"Clustering batch and biological conditions.\")\n  setwd(batch_dir)\n  pdf(batch_plot_out,  width=16, height=16)\n  dat.dist<-dist(t(countDat))\n  par(mfrow = c(2, 1), mar = c(3,5,3,1))\n  plot(hclust(dat.dist), cex=.75, label=batch_cond, main=\"Batch\")\n  plot(hclust(dat.dist), cex=.75, label=bio_cond, main=\"Biological Condition\")\n  dev.off()\n  setwd(working_dir)\n}\n\n\n#' make_PCA\n#'\n#' This function creates a PCA plot of rlog-transformed data based on provided\n#' conditions of interest.  Output written as PDF.\n#' @param rld rlog transformed data from DESeq2 object.\n#' @param cond Conditions to examine.  Must correspond to a column or list of columns in target data. If prep_dds was used, target data is\n#' stored as a global variable, targetDat.  A list of valid columns can be identified by checking column names of targetDat.  Input can be a single\n#' or multiple concatenation of targetDat column names. (I.E. c(\"Treatment\", \"Infection\")).\n#' @param numGenes Number of genes from which to compute eigenvectors.  Lower numbers will increase total variance captured by the plot. OPTIONAL. Default=All Genes.\n#' @keywords pca batch cluster\n#' @export\n#' @examples\n#' make_PCA()\nmake_PCA <- function(rld, cond, numGenes=0)\n{\n  print(\"Creating PCA plot...\")\n  setwd(PCA_dir)\n  pdf(PCA_plot_infect, width=8, height=8)\n  if (numGenes == 0)\n  {\n    print(\"Generating PCA based on all genes...\")\n    print(plotPCA(rld, intgroup = cond))\n  }\n  else\n  {\n    print(\"Generating PCA based on subset of genes.\")\n    print(plotPCA(rld, intgroup = cond, numGenes))\n  }\n  dev.off()\n  setwd(working_dir)\n}\n\n\n#' euclid_dist\n#'\n#' This function computes and plots sample distances (euclidian distance) in a heatmap.\n#' @param rld rlog transformed data\n#' @param row_labels Row labels for samples. Generally a field extracted from the rld object: (colData names).\n#' @keywords sample distance cluster euclidian\n#' @export\n#' @examples\n#' euclid_dist(rld, rld$Virus_Treatment)\neuclid_dist <- function(rld, row_labels)\n{\n  print(\"Plotting euclidian distances...\")\n  sampleDists <- dist( t( assay(rld) ) )\n  setwd(euclidian_dir)\n  sampleDistMatrix <- as.matrix( sampleDists )\n  rownames(sampleDistMatrix) <- row_labels\n  colnames(sampleDistMatrix) <- NULL\n  colors <- colorRampPalette( rev(brewer.pal(9, \"Blues\")) )(255)\n\n  pheatmap(sampleDistMatrix,\n           clustering_distance_rows=sampleDists,\n           clustering_distance_cols=sampleDists,\n           col=colors,\n           main=\"Euclidian Distances\",\n           filename=euclid_plot_out)\n  setwd(working_dir)\n}\n\n\n#' poisson_dist\n#'\n#' This function computes and plots sample distances (poisson distance) in a heatmap.\n#' @param rld rlog transformed data.\n#' @param row_labels Row labels for samples.  Generally a field extracted from the rld object: (colData names).\n#' @keywords sample distance cluster poisson\n#' @export\n#' @examples\n#' poisson_dist(rld, rld$Virus_Treatment)\npoisson_dist <- function(rld, row_labels)\n{\n  print(\"Plotting Poisson distances...\")\n  setwd(poisson_dir)\n  poisd <- PoissonDistance(t(counts(dds)))\n  colors <- colorRampPalette( rev(brewer.pal(9, \"Blues\")) )(255)\n  samplePoisDistMatrix <- as.matrix( poisd$dd )\n  rownames(samplePoisDistMatrix) <- row_labels\n  colnames(samplePoisDistMatrix) <- NULL\n  pheatmap(samplePoisDistMatrix,\n           clustering_distance_rows=poisd$dd,\n           clustering_distance_cols=poisd$dd,\n           col=colors,\n           main=\"Poisson Distances\",\n           filename=poisson_plot_out)\n  setwd(working_dir)\n}\n\n\n#' plot_mds\n#'\n#' This function computes and plots MDS of the r-log adjusted data.\n#' @param rld rlog transformed data.\n#' @param row_labels Row labels for samples.  Generally a field extracted from the rld object: (colData names).\n#' @keywords mds multi-dimensional scaling eigenvector eigenvalue distance\n#' @export\n#' @examples\n#' plot_mds()\nplot_mds <- function(rld, row_labels)\n{\n  print(\"Creating MDS plot...\")\n  setwd(MDS_dir)\n  sampleDists <- dist( t( assay(rld) ) )\n  sampleDistMatrix <- as.matrix( sampleDists )\n  pdf(MDS_plot_out, width=8, height=8)\n  mds <- data.frame(cmdscale(sampleDistMatrix))\n  mds <- cbind(mds, as.data.frame(colData(rld)))\n  print(ggplot(mds, aes(X1,X2,color=row_labels)) + geom_point(size=3) + ggtitle(\"MDS Plot\") + theme(plot.title = element_text(lineheight=.8, face=\"bold\"), legend.title=element_blank()) )\n  dev.off()\n  setwd(working_dir)\n}\n\n\n#' write_num_de\n#'\n#' This function writes the number of DE genes identified to a file for a provided result set.\n#' @param res DE result set such as that generated with results(dds, alpha=signif_cutoff).\n#' @keywords DE count save data storage\n#' @export\n#' @examples\n#' write_num_de(res)\nwrite_num_de <- function(res, cond=\"none\")\n{\n\n  if(cond != \"none\")\n  {\n    print(\"Adjusting output file name to reflect specified condition.\")\n    DE_count_out <<- paste(base_name, \"_\", cond, \"_DE_count_\", as.character(signif_cutoff), \".txt\", sep=\"\")\n  }\n\n  setwd(DE_count_dir)\n  num_DE = table(res$padj < signif_cutoff)[2]\n  print(num_DE)\n  print(\"1\")\n  de_set <- head(res[ order( res$padj ), ], n=num_DE)\n  print(\"2\")\n  num_down = nrow(de_set[which(de_set$log2FoldChange < 0),])\n  print(\"3\")\n  num_up = nrow(de_set[which(de_set$log2FoldChange >= 0),])\n  print(\"4\")\n  regulation = c(\"Down\", \"Up\")\n  numDE = c(num_down,num_up)\n  print(\"5\")\n  DE_countTable = list(rbind(regulation, numDE))\n  print(\"6\")\n  write.table(DE_countTable, DE_count_out, sep=\"\\t\", col.names=NA)\n  setwd(working_dir)\n}\n\n\n#' prep_counts\n#'\n#' This function takes a count data file and returns the formatted data. Requires that init_data_paths() has been run.\n#' @param count_input Count data in tab seperated format, assumes headers exist for each column.\n#' @param delim Indicate if file is comma or tab delimited.  \"t\" indicated tab delimited and \"c\" indicates comma seperated data.  Default: \"t\"\n#' @keywords count sample preperation design model structure\n#' @export\n#' @examples\n#' myCounts <- prep_counts(count_input_path)\nprep_counts <- function(count_input, delim=\"t\")\n{\n  if(delim != \"t\" && delim != \"c\")\n  {\n    print(\"Error: Possible delimiter values are 't' (tab-delimited), or 'c' (comma-seperated).\")\n    return(-1)\n  }\n\n  #Read count matrix.\n  print(\"Reading count file...\")\n  setwd(counts_dir)\n  if(delim == \"t\")\n  {\n    counts <- read.csv(count_input, header=TRUE, sep=\"\\t\")\n  }\n  if(delim == \"c\")\n  {\n    counts <- read.csv(count_input, header=TRUE, sep=\",\")\n  }\n  setwd(working_dir)\n  rownames(counts) <- counts$X\n  counts <- counts[,c(2:ncol(counts))]\n  return(counts)\n}\n\n\n#' prep_targets\n#'\n#' This function takes a target data file and returns the formatted data. Requires that init_data_paths() has been run.\n#' @param target_input Target data in tab seperated format, assumes headers exist for each column.\n#' @param delim Indicate if file is comma or tab delimited.  \"t\" indicated tab delimited and \"c\" indicates comma seperated data.  Default: \"t\"\n#' @keywords target sample preperation design model structure\n#' @export\n#' @examples\n#' myTargets <- prep_targets(target_input_path)\nprep_targets <- function(target_input, delim=\"t\")\n{\n  if(delim != \"t\" && delim != \"c\")\n  {\n    print(\"Error: Possible delimiter values are 't' (tab-delimited), or 'c' (comma-seperated).\")\n    return(-1)\n  }\n\n  #Read target matrix.\n  print(\"Reading targets file...\")\n  setwd(targets_dir)\n  if(delim == \"t\")\n  {\n    targets <- read.csv(target_input, header=TRUE, sep=\"\\t\")\n  }\n  if(delim == \"c\")\n  {\n    targets <- read.csv(target_input, header=TRUE, sep=\",\")\n  }\n  setwd(working_dir)\n  rownames(targets) <- targets$X\n  targets <- targets[,c(2:ncol(targets))]\n\n  tgt_dat <<- targets\n\n  return(targets)\n}\n\n\n#' prep_dds_from_data\n#'\n#' This function takes count data / targets data and creates a DESeq2 object based on the provided design. Count data will be stored as a global\n#' variable, countDat, and target data as, targetDat.\n#' @param count_input Count data in dataframe format.  Column names must correspond to target rownames.\n#' @param target_input Target data in dataframe format.  Row names must correspond to count column names.\n#' @param experiment_design Experimental design for DE comparison.  Can include multiple factors.  Design factors should correspond to column names\n#' in the provided targets file.  Include the primary factor as the final factor in the design and any secondary or batch effects prior.\n#' Must be prefaced with a tilde (~).   I.E. ~ Batch1 + Batch2 + SecondaryCondition + PrimaryCondition\n#' @param collapseReps Boolean. Collapse technical replicates. Default: False\n#' @param rep_field_vector Vector identifying which samples correspond to which replicates.  Generally a field from the targets file that identifies\n#' and maps samples to their replicate identifiers.  Required if collapseReps is TRUE.\n#' @keywords dds sample preperation design model structure\n#' @export\n#' @examples\n#' prep_dds_from_data(day1_ACali09_counts_path, day1_ACali09_targets_path, ~ Batch + Virus, TRUE, target_data$Replicate)\nprep_dds_from_data <- function(count_input, target_input, experiment_design, collapseReps=FALSE, rep_field_vector, stabilization=\"rld\")\n{\n  #Confirm parameters.\n  if(stabilization != \"rld\" && stabilization != \"vst\")\n  {\n    stop(\"Possibile values for stabilization are \\\"rld\\\" and \\\"vst\\\".  Use vst for larger data sets.\")\n    return(-1)\n  }\n\n  #Create DESeq Object and specify design parameters.\n  print(\"Creating DESeq Object...\")\n  countDat  <<- count_input\n  targetDat <<- target_input\n  dds <- DESeqDataSetFromMatrix(countData = count_input, colData = target_input, design = experiment_design)\n\n  if(collapseReps == TRUE)\n  {\n    print(\"Collapsing replicates...\")\n    dds <- collapseReplicates(dds,rep_field_vector)\n  }\n\n  #TMM normalization.\n  print(\"Performing TMM normalization...\")\n  dds <- estimateSizeFactors(dds)\n\n  #Do the necessary data transformation.\n  if(stabilization == \"rld\")\n  {\n    print(\"Performing rLog transform...\")\n    stabilized_data <<- rlog(dds)\n  }\n  if(stabilization == \"vst\")\n  {\n    print(\"Performing variance stabilization.\")\n    stabilized_data <<- varianceStabilizingTransformation(dds)\n  }\n\n  print(\"DESeq Object prepared.\")\n\n  return(dds)\n\n}\n\n\n#' prep_rld_from_dds\n#'\n#' This function takes a DESeq object and returns the rLog transformed data for the object.\n#' @param dds A DESeq Object.\n#' @keywords rlog transform data rld sample preperation design model structure\n#' @export\n#' @examples\n#' myTargets <- prep_rld_from_dds(dds)\nprep_rld_from_dds <- function(dds)\n{\n  #R-log Transform the data.\n  print(\"Performing rlog transformation...\")\n  rld <- rlog(dds)\n}\n\n\n#' prep_dds_from_file\n#'\n#' This function takes count data file locations and targets file locations and creates a DESeq2 object based on the provided design. Count data will be stored as a global\n#' variable, countDat, and target data as, targetDat.\n#' @param count_input Count data in tab seperated format, assumes headers exist for each column.\n#' @param target_input Target data in comma seperated format.  Assumes row names that correspond to count input column names.\n#' @param experiment_design Experimental design for DE comparison.  Can include multiple factors.  Design factors should correspond to column names\n#' in the provided targets file.  Include the primary factor as the final factor in the design and any secondary or batch effects prior.\n#' Must be prefaced with a tilde (~).   I.E. ~ Batch1 + Batch2 + SecondaryCondition + PrimaryCondition\n#' @param return_toggle Request the function to return the rlog/vst transformed data instead of the dds object be specifying return_toggle=\"rld\" or \"vst\". Default=\"dds\"\n#' @param method Variance stabilization method.  Possible values are \"rld\" (rLog transform), and \"vst\" (variance stabilizing transform).  rLog transform is suggested\n#' where possible as it is more sensitive.  Variance stabilizing transforms can be used when data sets are larger and rLog calculation time is extensive.  Default=\"rld\"\n#' @keywords dds sample preperation design model structure\n#' @export\n#' @examples\n#' prep_dds_from_file(day1_ACali09_counts_path, day1_ACali09_targets_path, ~ Batch + Virus)\nprep_dds_from_file <- function(count_input, target_input, experiment_design, return_toggle=\"dds\", method=\"rld\")\n{\n  #Read count matrix.\n  print(\"Reading count file...\")\n  setwd(counts_dir)\n  counts <- read.csv(count_input, header=TRUE, sep=\"\\t\")\n  setwd(working_dir)\n  rownames(counts) <- counts$X\n  counts <- counts[,c(2:ncol(counts))]\n  countDat <<- counts\n\n  #Read associated target matrix.\n  print(\"Reading targets file...\")\n  setwd(targets_dir)\n  targets <- read.csv(target_input)#, header=TRUE, sep=\"\\t\")\n  setwd(working_dir)\n  rownames(targets) <- targets$X\n  targets <- targets[,c(2:ncol(targets))]\n  targetDat <<- targets\n\n  #Create DESeq Object and specify design parameters.\n  print(\"Creating DESeq Object...\")\n  dds <- DESeqDataSetFromMatrix(countData = counts, colData = targets, design = experiment_design)\n  dds <- collapseReplicates(dds,targets$SampleName)\n\n  if(method == \"rld\")\n  {\n    #R-log Transform the data.\n    print(\"Performing rlog transformation...\")\n    rld <- rlog(dds)\n  }\n  if(method == \"vst\")\n  {\n    #R-log Transform the data.\n    print(\"Performing variance stabilizing transformation...\")\n    rld <- varianceStabilizingTransformation(dds)\n  }\n\n  #TMM normalization.\n  print(\"Performing TMM normalization...\")\n  dds <- estimateSizeFactors(dds)\n\n  if(return_toggle == \"rld\" || return_toggle == \"vst\")\n  {\n    return(rld)\n  }\n  else\n  {\n    return(dds)\n  }\n}\n\n\n#' plot_MA\n#'\n#' This function generates a MA plot showing dispersion and DE genes relative to that dispersion.\n#' @param res DE result set such as that generated with results(dds, alpha=signif_cutoff).\n#' @keywords dispersion differential expression expressed MA plot\n#' @export\n#' @examples\n#' plot_MA(res)\nplot_MA <- function(res)\n{\n  print(\"Creating MA plot...\")\n  setwd(MA_dir)\n  pdf(MA_plot_out, width=8, height=8)\n  plotMA(res, ylim=c(-9,9))\n  dev.off()\n  setwd(working_dir)\n}\n\n\n#' highVar_heat\n#'\n#' This function generates a heatmap and associated data files for the DE genes with the highest variance.\n#' @param rld rlog transformed data.\n#' @param res Result set of differential expression from DESeq2 created through results(dds, ... ).\n#' @param anno_df Annotation data frame where rownames match colnames of rld.\n#' @param col_labs Column labels for heatmap.  Generally a field extracted from the rld object: (colData names).\n#' @param ntop Top n genes sorted by highest variance.  Default: 100\n#' @keywords heat map heatmap variance DE visualization\n#' @export\n#' @examples\n#' anno_df <- as.data.frame(colData(rld)[,c(\"Virus\",\"Treatment\")])\n#' col_labels <- as.character(rld$Replicate)\n#' highVar_heat(rld, anno_df, col_labels)\nhighVar_heat <- function(rld, res, anno_df, col_labs, ntop=100)\n{\n  print(\"Clustering highly variable genes...\")\n  setwd(high_var_dir)\n  topVarGenes <- head(order(-rowVars(assay(rld))),ntop)\n  statsList = res[head(order(-rowVars(assay(rld))),ntop),]\n  mat <- assay(rld)[ topVarGenes, ]\n  mat_raw <- data.frame(mat)\n  mat <- mat - rowMeans(mat)\n  mat_df <- data.frame(mat)\n\n  pheatmap(mat, annotation_col=anno_df, labels_col=col_labs, fontsize_row=4, fontsize_col=7, width=12, height=12, filename=gene_cluster_out)\n\n  #Write high-variance gene list.\n  print(\"Writing high-variance gene list...\")\n  setwd(DE_dir)\n  write.table(mat_raw, highVar_list_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(DE_stats_dir)\n  write.table(statsList, cluster_stats_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(working_dir)\n}\n\n\n#' upreg_heat\n#'\n#' This function generates a heatmap and associated data files for the top most upregulated DE genes.\n#' @param rld rlog transformed data.\n#' @param res Result set of differential expression from DESeq2 created through results(dds, ... ).\n#' @param anno_df Annotation data frame where rownames match colnames of rld.\n#' @param col_labs Column labels for heatmap.  Generally a field extracted from the rld object: (colData names).\n#' @param ntop Top n genes sorted by highest upregulation.  Default: 50\n#' @keywords heat map heatmap upregulated upreg DE\n#' @export\n#' @examples\n#' upreg_heat(rld, anno_df, col_labels, 100)\nupreg_heat <- function(rld, res, anno_df, col_labs, ntop=50)\n{\n  #Plot most upregulated genes.\n  setwd(DE_up_dir)\n  upgenes <- rownames(head(res[ order( -res$log2FoldChange ), ], n=ntop))\n  statsList <- head(res[ order( -res$log2FoldChange ), ], n=ntop)\n  rows <- match(upgenes, row.names(rld))\n  mat <- assay(rld)[rows,]\n  mat_raw <- data.frame(mat)\n  mat <- mat - rowMeans(mat)\n  mat_df <- data.frame(mat)\n\n  pheatmap(mat, annotation_col=anno_df, labels_col=col_labs, fontsize_row=4, fontsize_col=7, width=12, height=12, filename=upreg_plot_out)\n\n  #Write top upregulated gene list.\n  print(\"Writing top upreg gene list...\")\n  setwd(DE_dir)\n  write.table(mat_raw, upreg_list_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(DE_stats_dir)\n  write.table(statsList, upreg_stats_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(working_dir)\n}\n\n\n#' downreg_heat\n#'\n#' This function generates a heatmap and associated data files for the top most downregulated DE genes.\n#' @param rld rlog transformed data.\n#' @param res Result set of differential expression from DESeq2 created through results(dds, ... ).\n#' @param anno_df Annotation data frame where rownames match colnames of rld.\n#' @param col_labs Column labels for heatmap.  Generally a field extracted from the rld object: (colData names).\n#' @param ntop Top n genes sorted by highest downregulation.  Default: 50\n#' @keywords heat map heatmap downregulated downreg DE\n#' @export\n#' @examples\n#' downreg_heat(rld, anno_df, col_labels, 25)\ndownreg_heat <- function(rld, res, anno_df, col_labs, ntop=50)\n{\n  #Plot most downregulated genes.\n  setwd(DE_down_dir)\n  downgenes <- rownames(head(res[ order( res$log2FoldChange ), ], n=ntop))\n  statsList <- head(res[ order( res$log2FoldChange ), ], n=ntop)\n  rows <- match(downgenes, row.names(rld))\n  mat <- assay(rld)[rows,]\n  mat_raw <- data.frame(mat)\n  mat <- mat - rowMeans(mat)\n  mat_df <- data.frame(mat)\n\n  pheatmap(mat, annotation_col=anno_df, labels_col=col_labs, fontsize_row=4, fontsize_col=7, width=12, height=12, filename=downreg_plot_out)\n\n  #Write top downregulated gene list.\n  print(\"Writing top downreg gene list...\")\n  setwd(DE_dir)\n  write.table(mat_raw, downreg_list_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(DE_stats_dir)\n  write.table(statsList, downreg_stats_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(working_dir)\n}\n\n\n#' topDE_heat\n#'\n#' This function generates a heatmap and associated data files for the most significant DE genes.\n#' @param rld rlog transformed data.\n#' @param res Result set of differential expression from DESeq2 created through results(dds, ... ).\n#' @param anno_df Annotation data frame where rownames match colnames of rld.\n#' @param col_labs Column labels for heatmap.  Generally a field extracted from the rld object: (colData names).\n#' @param ntop Top n genes sorted by most significant p-value.  Default: 100\n#' @keywords heat map heatmap significant p-value DE visualization\n#' @export\n#' @examples\n#' topDE_heat(rld, anno_df, col_labels)\ntopDE_heat <- function(rld, res, anno_df, col_labs, ntop=100)\n{\n  #Plot top 100 genes.\n  setwd(top_100_dir)\n  de_set <- rownames(head(res[ order( res$padj ), ], n=ntop))\n  statsList <- head(res[ order( res$padj ), ], n=ntop)\n  rows <- match(de_set, row.names(rld))\n  mat <- assay(rld)[rows,]\n  mat_raw <- data.frame(mat)\n  mat <- mat - rowMeans(mat)\n  mat_df <- data.frame(mat)\n\n  pheatmap(mat, annotation_col=anno_df, labels_col=col_labs, fontsize_row=4, fontsize_col=7, width=12, height=24, filename=DE_top100_out)\n\n  #Write top 100 DE gene list.\n  print(\"Writing top 100 DE gene list...\")\n  setwd(DE_dir)\n  write.table(mat_raw, DE_top100_list_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(DE_stats_dir)\n  write.table(statsList, DE_top100_stats_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(working_dir)\n}\n\n\n#' allDE_heat\n#'\n#' This function generates a heatmap and associated data files for all significant DE genes.\n#' @param rld rlog transformed data.\n#' @param res Result set of differential expression from DESeq2 created through results(dds, ... ).\n#' @param anno_df Annotation data frame where rownames match colnames of rld.\n#' @param col_labs Column labels for heatmap.  Generally a field extracted from the rld object: (colData names).\n#' @keywords heat map heatmap significant p-value DE visualization\n#' @export\n#' @examples\n#' allDE_heat(rld, res, anno_df, col_labels)\nallDE_heat <- function(rld, res, anno_df, col_labs)\n{\n  #Plot all DE genes.\n  setwd(DE_all_dir)\n  num_DE = table(res$padj < signif_cutoff)[2]\n  de_set <- rownames(head(res[ order( res$padj ), ], n=num_DE))\n  statsList <- head(res[ order( res$padj ), ], n=num_DE)\n  rows <- match(de_set, row.names(rld))\n  mat <- assay(rld)[rows,]\n  mat_raw <- data.frame(mat)\n  mat <- mat - rowMeans(mat)\n  mat_df <- data.frame(mat)\n\n  pheatmap(mat, annotation_col=anno_df, labels_col=col_labs, fontsize_row=4, fontsize_col=7, width=12, height=24, filename=de_plot_out)\n\n  #Write all DE gene list.\n  print(\"Writing all DE gene list...\")\n  setwd(DE_dir)\n  write.table(mat_raw, DE_list_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(DE_stats_dir)\n  write.table(statsList, DE_stats_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(working_dir)\n}\n\n\n#' filter_DE_pval\n#'\n#' This function filteres a provided result set to only contain genes with p-values lower than the provided cuttoff.\n#' @param res Result set of differential expression from DESeq2 created through results(dds, ... ).\n#' @param pval P-value cutoff to filter the data with. Default=0.05\n#' @keywords filtering p-value cutoff filter\n#' @export\n#' @examples\n#' filter_DE_pval(res, 0.01)\nfilter_DE_pval <- function(res, pval=0.05)\n{\n  tmp1 <- res[which(!is.na(res$padj)),]\n  tmp2 <- tmp1[which(tmp1$padj < pval),]\n  numDE <- nrow(tmp2)\n  cat(\"Number of DE genes after p-value filter:\", numDE)\n  return(tmp2)\n}\n\n\n#' filter_DE_lfc\n#'\n#' This function filteres a provided result set to only contain genes with log2FoldChange lower than the provided cuttoff.\n#' @param res Result set of differential expression from DESeq2 created through results(dds, ... ).\n#' @param lfc Log2 fold-change value to use as cutoff. Default=1.5\n#' @keywords filtering lfc log2foldchange fold-change filter\n#' @export\n#' @examples\n#' filter_DE_lfc()\nfilter_DE_lfc <- function(res, lfc=1.5)\n{\n  tmp1 <- res[which(!is.na(res$padj)),]\n  tmp2 <- tmp1[which(tmp1$log2FoldChange > lfc),]\n  numDE <- nrow(tmp2)\n  cat(\"Number of DE genes after log2FoldChange filter:\", numDE)\n  return(tmp2)\n}\n\n\n#' get_intersect_dds\n#'\n#' This function returns the intersection of genes for two DESeq objects. Also used as a helper function for\n#' pairwise_intersect.  Uses cutoff values determined by init_cutoffs()\n#' @param dds1 A complete DESeq object with DE already calculated.\n#' @param dds2 A complete DESeq object with DE already calculated.\n#' @keywords filtering intersect set operation helper\n#' @export\n#' @examples\n#' get_intersect_dds(dds1,dds2)\nget_intersect_dds <- function(dds1,dds2)\n{\n  #Get significant DE genes for both sets.\n  res1 <- results(dds1, alpha=signif_cutoff)\n  mcols(res1, use.names=TRUE)\n  summary(res1)\n  table(res1$padj < signif_cutoff)\n  num_DE = table(res1$padj < signif_cutoff)[2]\n  de_set1 <- rownames(head(res1[ order( res1$padj ), ], n=num_DE))\n\n  res2 <- results(dds2, alpha=signif_cutoff)\n  mcols(res2, use.names=TRUE)\n  summary(res2)\n  table(res2$padj < signif_cutoff)\n  num_DE = table(res2$padj < signif_cutoff)[2]\n  de_set2 <- rownames(head(res2[ order( res2$padj ), ], n=num_DE))\n\n  return(intersect(de_set1, de_set2))\n}\n\n\n#' get_intersect_res\n#'\n#' This function returns the intersection of genes for two DESeq result sets. Also used as a helper function for\n#' pairwise_intersect.  Uses cutoff values determined by init_cutoffs()\n#' @param dds1 A complete DESeq object with DE already calculated.\n#' @param dds2 A complete DESeq object with DE already calculated.\n#' @keywords filtering intersect set operation helper\n#' @export\n#' @examples\n#' get_intersect_res(dds1,dds2)\nget_intersect_res <- function(res1,res2)\n{\n  #Get significant DE genes for both sets.\n  mcols(res1, use.names=TRUE)\n  summary(res1)\n  table(res1$padj < signif_cutoff)\n  num_DE = table(res1$padj < signif_cutoff)[2]\n  de_set1 <- rownames(head(res1[ order( res1$padj ), ], n=num_DE))\n\n  mcols(res2, use.names=TRUE)\n  summary(res2)\n  table(res2$padj < signif_cutoff)\n  num_DE = table(res2$padj < signif_cutoff)[2]\n  de_set2 <- rownames(head(res2[ order( res2$padj ), ], n=num_DE))\n\n  return(intersect(de_set1, de_set2))\n}\n\n\n#' filter_DE_lfc\n#'\n#' This function calculates the intersections for all permutations of the provided list of DESeq objects and returnes a list of pairwise intersections.\n#' Significance cutoffs are determined by the fuction init_cutoffs().  Uses get_intersect() as a helper function.\n#' @param dds_set A list of complete DESeq object with DE already calculated.\n#' @keywords filtering intersect set operation helper pairwise\n#' @export\n#' @examples\n#' pairwise_intersect(dds1_list)\npairwise_intersect <- function(dds_set)\n{\n  intersect_genes <- list()\n  combn_set = combn(1:length(dds_set),2)\n  for (i in 1:ncol(combn_set))\n  {\n    set1 = dds_set[[combn_set[1,i]]]\n    set2 = dds_set[[combn_set[2,i]]]\n    cur_intersect = get_intersect_res(set1,set2)\n    intersect_genes[i] <- list(cur_intersect)\n  }\n\n  return(intersect_genes)\n}\n\n\n#' get_de_matrix\n#'\n#' This function returns a matrix type object containing log2 fold-change values that have been normalized to the mean expression\n#' level for that gene.  Relies on init_cutoffs() significant thresholds.\n#' @param dds A complete DESeq object with DE already calculated.\n#' @param rld rLog transformed expression data for the associated DESeq object.\n#' @keywords filtering matrix extraction differential expression values\n#' @export\n#' @examples\n#' get_de_matrix(dds, rld)\nget_de_matrix <- function(dds, rld)\n{\n  res <- results(dds, alpha=signif_cutoff)\n  mcols(res, use.names=TRUE)\n  summary(res)\n  table(res$padj < signif_cutoff)\n\n  num_DE = table(res$padj < signif_cutoff)[2]\n  de_set <- rownames(head(res[ order( res$padj ), ], n=num_DE))\n  rows <- match(de_set, row.names(rld))\n  mat <- assay(rld)[rows,]\n  mat <- mat - rowMeans(mat) #Normalize to the row mean values for each gene.\n\n  return(mat)\n}\n\n\n#' get_de_stats\n#'\n#' This function returns a table of statistical information for DE genes in a given DESeq object.\n#' Relies on init_cutoffs() significant thresholds.\n#' @param dds A complete DESeq object with DE already calculated.\n#' @keywords statistics differential expression values DE stats table\n#' @export\n#' @examples\n#' get_de_stats(dds)\nget_de_stats <- function(dds)\n{\n  res <- results(dds, alpha=signif_cutoff)\n  mcols(res, use.names=TRUE)\n  summary(res)\n  table(res$padj < signif_cutoff)\n  num_DE = table(res$padj < signif_cutoff)[2]\n  statsList <- head(res[ order( res$padj ), ], n=num_DE)\n\n  return(statsList)\n}\n\n\n#' get_de_res\n#'\n#' This function returns a result set object based on a complete DESeq object.\n#' Relies on init_cutoffs() significant thresholds.\n#' @param dds A complete DESeq object with DE already calculated.\n#' @keywords statistics differential expression values DE result table\n#' @export\n#' @examples\n#' get_de_res(dds)\nget_de_res <- function(dds)\n{\n  res <- results(dds, alpha=signif_cutoff)\n  mcols(res, use.names=TRUE)\n  summary(res)\n  table(res$padj < signif_cutoff)\n\n  return(res)\n}\n\n\n\n#' enrich_res\n#'\n#' Given a DESeq result set, this function adds several additional components to the object.\n#' Variables created are numDE, numUp, numDown, allNames, upNames, and downNames, allDE, upDE, downDE, case, control, contrast, and designField.\n#' @param resVarName The name of the variable for your result set.  Must be a string representation of the variable name.\n#' The variable itself should be a DESeq object of type S4.  For example, if your DESeq result set is called myResSet,\n#' then you should pass \"myResSet\" as a string. New information will be processed and made available to your DESeq result set.\n#' @keywords DE data extraction aggregation simplification\n#' @export\n#' @examples\n#' enrich_res(myResSet)\nenrich_res <- function(res)\n{\n  #Make sure they're passing us the correct type of object.\n  #try(if(typeof(res) != \"S4\") stop(\"Error: enrich_res requires S4 type object as result set for parameter res.\", call. = FALSE))\n\n  #Create a class that inherits DESeqResults class, and contains extra slots for metadata we want for data visualization and aggregation.\n  newRes = new(\"DESeqResMeta\")\n\n  #Populate the new object with all the values from the initial result set.\n  newRes@rownames <- res@rownames\n  newRes@nrows <- res@nrows\n  newRes@listData <- res@listData\n  newRes@elementType <- res@elementType\n  newRes@elementMetadata <- res@elementMetadata\n  newRes@metadata <- res@metadata\n  newRes$baseMean <- res$baseMean\n  newRes$log2FoldChange <- res$log2FoldChange\n  newRes$lfcSE <- res$lfcSE\n  newRes$stat <- res$lfcSE\n  newRes$pvalue <- res$pvalue\n  newRes$padj <- res$padj\n\n  #Fill the additional values with new metadata.\n\n  #See if the result set has any DE genes at all.\n  if(!is.na(table(res$padj < signif_cutoff)[2]))\n  {\n    numDE = table(res$padj < signif_cutoff)[2]\n  }\n  else\n  {\n    numDE = 0\n  }\n  newRes@numDE = numDE\n\n  #Extract all DE names and store.\n  DE_names <- rownames(head(res[order(res$padj),], n=newRes@numDE))\n  newRes@allNames <- DE_names\n\n  #Extract number upregulated and downregulated, then store.\n  if(!is.na(table(res$padj < signif_cutoff & res$log2FoldChange < 0)[2]))\n  {\n    numDown = table(res$padj < signif_cutoff & res$log2FoldChange < 0)[2]\n  }\n  else\n  {\n    numDown = 0\n  }\n  if(!is.na(table(res$padj < signif_cutoff & res$log2FoldChange > 0)[2]))\n  {\n    numUp = table(res$padj < signif_cutoff & res$log2FoldChange > 0)[2]\n  }\n  else\n  {\n    numUp = 0\n  }\n  newRes@numDown <- numDown\n  newRes@numUp <- numUp\n\n\n  #Extract and store the up and downregulard DE gene names.\n  downNames = rownames(res)[which(res$padj < signif_cutoff & res$log2FoldChange < 0)]\n  upNames   = rownames(res)[which(res$padj < signif_cutoff & res$log2FoldChange > 0)]\n  newRes@downNames <- downNames\n  newRes@upNames <- upNames\n\n\n  #Attach metadata about comparisons.\n  case = unlist(strsplit(res@elementMetadata$description[2], split=\" \"))[6]\n  control = unlist(strsplit(res@elementMetadata$description[2], split=\" \"))[8]\n  design_field = unlist(strsplit(res@elementMetadata$description[2], split=\" \"))[5]\n  contrast = paste(case,\"_vs_\",control,sep=\"\")\n\n  newRes@case <- case\n  newRes@control <- control\n  newRes@design_field <- design_field\n  newRes@contrast <- contrast\n\n\n  return(newRes)\n\n}\n\n\n#' allDE_heat2\n#'\n#' This function generates a heatmap and associated data files for all significant DE genes.\n#' @param rld rlog transformed data.\n#' @param res Result set of differential expression from DESeq2 created through results(dds, ... ).\n#' @param anno_df Annotation data frame where rownames match colnames of rld.\n#' @param col_labs Column labels for heatmap.  Generally a field extracted from the rld object: (colData names).\n#' @keywords heat map heatmap significant p-value DE visualization\n#' @export\n#' @examples\n#' allDE_heat2(rld, res, anno_df, col_labels)\nallDE_heat2 <- function(res, anno_cols=list(\"default\"))\n{\n\n  #Parameter validation.\n  if(typeof(res) != \"S4\")\n  {\n    stop(\"allDE_heat requires S4 type object as result set for parameter res.\")\n    return(-1)\n  }\n  if(class(res)[1] != \"DESeqResMeta\")\n  {\n    stop(\"allDE_heat requires enriched result set. Run enrich_res() first.\")\n    return(-1)\n  }\n  if(!exists(\"stabilized_data\"))\n  {\n    stop(\"DDS data for this experiment have not been transformed.  Did prep_dds_from_data() run correctly?\")\n    return(-1)\n  }\n\n  #Prepare annotation data.\n  if(anno_cols[[1]] == \"default\")\n  {\n    anno_contrast <- paste(\"stabilized_data@colData$\", res@design_field, sep=\"\")\n    anno_df = data.frame(eval(parse(text=anno_contrast)))\n  }\n  else\n  {\n    print(\"Two\")\n  }\n  print(anno_df)\n  return(anno_df)\n\n  #Plot all DE genes.\n  setwd(DE_all_dir)\n  num_DE = res@numDE\n  de_set <- rownames(head(res[ order( res$padj ), ], n=num_DE))\n  statsList <- head(res[ order( res$padj ), ], n=num_DE)\n  rows <- match(de_set, row.names(res))\n  mat <- assay(rld)[rows,]\n  mat_raw <- data.frame(mat)\n  mat <- mat - rowMeans(mat)\n  mat_df <- data.frame(mat)\n\n  pheatmap(mat, annotation_col=anno_df, labels_col=col_labs, fontsize_row=4, fontsize_col=7, width=12, height=24, filename=de_plot_out)\n\n  #Write all DE gene list.\n  print(\"Writing all DE gene list...\")\n  setwd(DE_dir)\n  write.table(mat_raw, DE_list_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(DE_stats_dir)\n  write.table(statsList, DE_stats_out, sep=\"\\t\", col.names=NA, row.names=TRUE)\n  setwd(working_dir)\n}\n",
    "created" : 1508423343778.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2379148518",
    "id" : "3002A374",
    "lastKnownWriteTime" : 1508426914,
    "last_content_update" : 1508426914422,
    "path" : "~/GitHub/staRNA-Seq/R/DEVis/DEVis/R/functions.R",
    "project_path" : "R/functions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}